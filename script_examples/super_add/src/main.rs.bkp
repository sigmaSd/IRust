use irust_api::{Command, OutputEvent, Shutdown};
use rscript::scripting::Scripter;
use rscript::{Hook, VersionReq};
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

fn copy_dir_to_temp(source: &Path) -> Result<PathBuf, Box<dyn std::error::Error>> {
    // Create a unique temporary directory name
    let temp_base = env::temp_dir();
    let temp_name = format!("temp_copy_{}", std::process::id());
    let temp_path = temp_base.join(temp_name);

    // Create the temporary directory
    fs::create_dir_all(&temp_path)?;

    // Copy the source directory contents to temp directory
    copy_dir_recursive(source, &temp_path)?;

    Ok(temp_path)
}

fn copy_dir_recursive(src: &Path, dst: &Path) -> Result<(), Box<dyn std::error::Error>> {
    if !dst.exists() {
        fs::create_dir_all(dst)?;
    }

    for entry in fs::read_dir(src)? {
        let entry = entry?;
        let src_path = entry.path();
        let dst_path = dst.join(entry.file_name());

        if src_path.is_dir() {
            copy_dir_recursive(&src_path, &dst_path)?;
        } else {
            fs::copy(&src_path, &dst_path)?;
        }
    }

    Ok(())
}

#[derive(Debug, Default)]
struct SuperAdd {}

impl Scripter for SuperAdd {
    fn name() -> &'static str {
        "SuperAdd"
    }

    fn script_type() -> rscript::ScriptType {
        rscript::ScriptType::Daemon
    }

    fn hooks() -> &'static [&'static str] {
        &[OutputEvent::NAME]
    }

    fn version_requirement() -> rscript::VersionReq {
        VersionReq::parse(">=1.50.0").expect("correct version requirement")
    }
}

fn main() {
    let _ = SuperAdd::execute(&mut |hook_name| SuperAdd::run(&mut SuperAdd {}, hook_name));
}

impl SuperAdd {
    fn run(&mut self, hook_name: &str) {
        match hook_name {
            OutputEvent::NAME => {
                let hook: OutputEvent = Self::read();
                let input = hook.1;
                if input.starts_with(":add") && input.contains("--path") {
                    let path = input
                        .split("--path")
                        .last()
                        .expect("path argument not found");
                    // copy the directory in path to a temp directory

                    let copy_dep = copy_dir_to_temp(&std::path::PathBuf::from(path))
                        .expect("failed to copy directory");
                } else {
                    Self::write(&None);
                }
            }
            _ => unreachable!(),
        }
    }

    fn clean_up(&self, _hook: Shutdown) -> Option<Command> {
        None
    }
}
